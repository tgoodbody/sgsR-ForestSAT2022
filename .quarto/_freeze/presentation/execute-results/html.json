{
  "hash": "41f5ec11bf91787f757991d79b263ddc",
  "result": {
    "markdown": "---\ntitle: \"`sgsR`: Structurally Guided Sampling\"\nauthor: \"_Tristan Goodbody, Nicholas Coops, Martin Queinnec, Joanne White, Piotr Tompalski, Andrew Hudak, David Auty, Ruben Valbuena, Antoine LeBoeuf, Ian Sinclair, Grant McCartney, Jean-Francois Prieur, Murray Woods_\"\ninstitute: \"__University of British Columbia__\"\nformat:\n  revealjs: \n    theme: sky\n    self-contained: true\n    slide-number: true\n    preview-links: auto\n    logo: images/logo.png\n    footer: <https://tgoodbody.github.io/sgsR/>\n    progress: true\n---\n\n\n\n\n## Overview\n\n::: incremental\n-   Brief inventory and sampling overview\n\n-   Discuss using auxiliary variables within sampling frameworks\n\n-   Structurally guided sampling using Airborne Laser Scanning\n\n-   `sgsR` overview\n\n-   Programmatic examples of the package\n:::\n\n## Forest inventories {.smaller}\n\n::: {.fragment .fade-up}\n**Purpose:** Obtain knowledge about the population (forest area) under investigation and provide estimates of specific target variables.\n:::\n\n::: {.fragment .fade-up}\n**Needed information:** Defined by the scope & scale of the inventory. Answered by questions like:\n:::\n\n::: incremental\n-   Who/what is the information for? (e.g. Reporting obligations, timber production)\n\n-   How big of an area are we inventorying? (e.g. National level, operational level)\n:::\n\n::: {.fragment .fade-up}\nAnswers dictate the sampling approaches to fulfill inventory obligations and objectives.\n:::\n\n## Sampling {.smaller}\n\n::: {.fragment .fade-up}\n-   ***Mensuration is a cornerstone of forest management.***\n:::\n\n::: {.fragment .fade-up}\n-   Sampling drives accurate forest attribute estimates (e.g. forest area, stem volume).\n:::\n\n::: {.fragment .fade-up}\nSampling can be:\n:::\n\n::: incremental\n-   Labour intensive\n\n-   Logistically challenging\n\n-   **Expensive**\n:::\n\n::: {.fragment .fade-up}\n-   We want to balance these challenges with attribute estimate accuracy\n:::\n\n::: {.fragment .fade-up}\n-   Many sampling methods, but traditional and commonly used examples include:\n:::\n\n## Probability-based sampling {.smaller}\n\nCommon sampling methods include randomized sampling where probabilities for each sample unit are known and equivalent.\n\n::: {.fragment .fade-up}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#--- simple random sampling ---#\nsample_srs(raster = mr, nSamp = 100, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=960}\n:::\n:::\n\n:::\n\n## Systematic sampling {.smaller}\n\n::: {.fragment .fade-up}\nSystematic sampling methods are also common, where sample units are selected based on a defined distance.\n:::\n\n::: {.fragment .fade-up}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#--- systematic sampling ---#\nsample_systematic(raster = mr, cellsize = 1000, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=960}\n:::\n:::\n\n:::\n\n##  {auto-animate=\"true\"}\n\nDifferent tessellation shapes are fairly common\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#--- systematic sampling in hexagons ---#\nsample_systematic(raster = mr, cellsize = 1000, square = FALSE, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n##  {auto-animate=\"true\"}\n\nAnd combinations of systematic and simple random sampling also exists\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#--- systematic random sampling ---#\nsample_systematic(raster = mr, cellsize = 1000, \n                  square = FALSE, location = \"random\", plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Auxiliary data {.smaller}\n\nProbability-based sampling does not leverage auxiliary data such as:\n\n![](images/auxiliary.png){fig-align=\"center\" width=\"717\"}\n\n::: {.fragment .fade-up}\n- Imagery, Feature-based inventories, ALS metrics (height, cover, variability)\n:::\n\n::: {.fragment .fade-up}\n- Auxiliary data as *a-priori* information to guide *model-based* sampling has been fruitful.\n:::\n\n<center>\n\n::: {.fragment .fade-up}\n*The ALS data also provides an excellent source of prior information that may be used in the design phase of the field survey to reduce the size of the field data set.* [Gobakken et al. (2013)](http://dx.doi.org/10.14214/sf.943)\n:::\n\n</center>\n\n## Stratification {.smaller}\n\nStratification using auxiliary data can lead to representative sampling approaches.\n\n::: {layout-ncol=\"2\"}\n\n![Hawbaker et al. (2009)](images/sgs.png)\n\n![Gobakken et al. (2013)](images/sgs2.png)\n\n:::\n\n##  {auto-animate=\"true\"}\n\n``` r\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           nStrata = 5) # 5 strata in p90\n```\n\n##  {auto-animate=\"true\"}\n\n``` {.r code-line-numbers=\"2\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           nStrata = 5) # 5 strata in p90\n```\n\n##  {auto-animate=\"true\"}\n\n``` {.r code-line-numbers=\"2-3\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           nStrata = 5) # 5 strata in p90\n```\n\n::: {.fragment .fade-up}\n![](images/strat_1.png){fig-align=\"center\"}\n:::\n\n##  {auto-animate=\"true\"}\n\n``` r\n#--- perform dual metric stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           mraster2 = mr$zsd, # standard deviation of height\n                           nStrata = 10, # 10 strata in p90\n                           nStrata2 = 3) # 3 strata in zsd\n```\n\n##  {auto-animate=\"true\"}\n\n``` {.r code-line-numbers=\"2,4\"}\n#--- perform dual metric stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           mraster2 = mr$zsd, # standard deviation of height\n                           nStrata = 10, # 10 strata in p90\n                           nStrata2 = 3) # 3 strata in zsd\n```\n\n##  {auto-animate=\"true\"}\n\n``` {.r code-line-numbers=\"3,5\"}\n#--- perform dual metric stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           mraster2 = mr$zsd, # standard deviation of height\n                           nStrata = 10, # 10 strata in p90\n                           nStrata2 = 3) # 3 strata in zsd\n```\n\n::: {.fragment .fade-up}\n![](images/strat_2.png){fig-align=\"center\"}\n:::\n\n## Structurally guided sampling {auto-animate=\"true\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mr$zq90, # p90\n                           mraster2 = mr$zsd, # standard deviation of height\n                           nStrata = 10, # 10 strata in p90\n                           nStrata2 = 3) # 3 strata in zsd\n\n#--- structurally guided stratified sampling ---#\nsample_strat(sraster = sraster, nSamp = 100, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-6-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## `sgsR`\n\n![](images/logo.png){fig-align=\"center\"}\n\n## `sgsR` purpose {.smaller}\n\nA growing number of studies have demonstrated that *a-priori* use of ALS metrics to guide sampling design provides methods that are:\n\n::: incremental\n-   transparent\n\n-   repeatable\n\n-   tuneable\n\n-   spatially-explicit\n:::\n\n::: {.fragment .fade-up}\n`sgsR` is intended to provide a simple to use toolbox for practitioners to leverage these benefits to provide primarily *model-based* sampling approaches for forest inventories.\n:::\n\n## overview\n\n![](images/flow.png){fig-align=\"center\"}\n\n## Algorithm structure {.smaller}\n\n::: incremental\n-   `sgsR` was built using the `terra`, `sf`, & `tidyverse` packages\n\n-   There are 4 primary function verbs that `sgsR` uses:\n\n    -   `strat_*` - apply stratification to metrics raster (mraster) and output a stratified raster (sraster)\n\n    -   `sample_*` - allocate samples using srasters produced from strat\\_\\* functions.\n\n    -   `calculate_*`- calculate sample information or create useful intermediary sampling products.\n\n    -   `extract_*` - extract pixels values from rasters to samples\n:::\n\n::: {.fragment .fade-in}\n![](images/flow-01.png){fig-align=\"center\"}\n:::\n\n## Example 1 - Stratified sampling\n\nLets read in some ALS metrics\n\n``` {.r code-line-numbers=\"1,3,5,6\"}\n#--- Stratification ---#\n#--- Load ALS metrics from sgsR internal data ---#\nr <- system.file(\"extdata\", \"mraster.tif\", package = \"sgsR\")\n\n#--- Read ALS metrics using the terra package ---#\nmraster <- terra::rast(r)\n```\n\n## Example 1 - Stratified sampling\n\nLets read in some ALS metrics - `mraster`.\n\n``` {.r code-line-numbers=\"6\"}\n#--- Stratification ---#\n#--- Load ALS metrics from sgsR internal data ---#\nr <- system.file(\"extdata\", \"mraster.tif\", package = \"sgsR\")\n\n#--- Read ALS metrics using the terra package ---#\nmraster <- terra::rast(r)\n```\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-7-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n##  {auto-animate=\"true\"}\n\nLets also read in a linear road `access` network.\n\n``` {.r code-line-numbers=\"4-5\"}\n#--- Load access network from sgsR internal data ---#\na <- system.file(\"extdata\", \"access.shp\", package = \"sgsR\")\n\n#--- load the access vector using the sf package ---#\naccess <- sf::st_read(a)\n```\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-8-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n##  {auto-animate=\"true\"}\n\nLike before, lets stratify `p90` in to 4 strata based on quantiles.\n\n``` r\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mraster$zq90, # input ALS metric - p90\n                           nStrata = 4) # desired number of strata (4)\n```\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-9-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n##  {auto-animate=\"true\"}\n\nNow lets use the `sraster` output.\n\n``` {.r code-line-numbers=\"6\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mraster$zq90, # input ALS metric - p90\n                           nStrata = 4) # desired number of strata (4)\n\n#--- perform sampling ---#\nsamples <- sample_strat(sraster = sraster, \n                        nSamp = 100, \n                        access = access, \n                        buff_inner = 50, \n                        buff_outer = 400)\n```\n\n##  {auto-animate=\"true\"}\n\nRequest 100 proportionally allocated samples.\n\n``` {.r code-line-numbers=\"6-7\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mraster$zq90, # input ALS metric - p90\n                           nStrata = 4) # desired number of strata (4)\n\n#--- perform sampling ---#\nsamples <- sample_strat(sraster = sraster, \n                        nSamp = 100, \n                        access = access, \n                        buff_inner = 50, \n                        buff_outer = 400)\n```\n\n##  {auto-animate=\"true\"}\n\nBring in the `access` road.\n\n``` {.r code-line-numbers=\"6-8\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mraster$zq90, # input ALS metric - p90\n                           nStrata = 4) # desired number of strata (4)\n\n#--- perform sampling ---#\nsamples <- sample_strat(sraster = sraster, \n                        nSamp = 100, \n                        access = access, \n                        buff_inner = 50, \n                        buff_outer = 400)\n```\n\n##  {auto-animate=\"true\"}\n\nSpecify we dont want samples within 50 m of `access`.\n\n``` {.r code-line-numbers=\"6-9\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mraster$zq90, # input ALS metric - p90\n                           nStrata = 4) # desired number of strata (4)\n\n#--- perform sampling ---#\nsamples <- sample_strat(sraster = sraster, \n                        nSamp = 100, \n                        access = access, \n                        buff_inner = 50, \n                        buff_outer = 400)\n```\n\n##  {auto-animate=\"true\"}\n\nOr further than 400 m from `access`.\n\n``` {.r code-line-numbers=\"6-10\"}\n#--- perform stratification ---#\nsraster <- strat_quantiles(mraster = mraster$zq90, # input ALS metric - p90\n                           nStrata = 4) # desired number of strata (4)\n\n#--- perform sampling ---#\nsamples <- sample_strat(sraster = sraster, \n                        nSamp = 100, \n                        access = access, \n                        buff_inner = 50, \n                        buff_outer = 400)\n```\n\n## Example 1 - Stratified Sampling\n\nMapped result **(A)** and plotted result **(B)**.\n\nNote buffered `access` in **A**. Points are samples in both **A** & **B**.\n\n![](images/example1.png){fig-align=\"center\"}\n\n## Comparing distributions {.smaller}\n\nWhen constraining by `access` its important to make sure that you're still sampling the entire distribution of metrics.\n\n-   We see that access constrained (green) and the full population (yellow) are very similar.\n\n![](images/accesscompare.png){fig-align=\"center\"}\n\n## Existing samples\n\n::: {.fragment .fade-in}\nPractitioners may ask:\n:::\n\n<center>\n\n::: {.fragment .fade-in}\n*\"I have an existing sample network, can I use those same sample locations?\"*\n:::\n\n::: {.fragment .fade-in}\n*\"If I go and visit those same sample units, where should I locate new samples for structural representation?\"*\n:::\n\n</center>\n\n## Augmenting an `existing` sample {.smaller}\n\n::: {.fragment .fade-in}\nLets create an `existing` sample of 50 plots using simple random sampling (`sample_srs`).\n:::\n\n::: {.fragment .fade-in}\n-   We are assuming these have been measured or used previously and can be revisited.\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(2022)\n#--- simple random sampling ---#\nexisting <- sample_srs(raster = mr, nSamp = 50, plot = TRUE)\n```\n\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-10-1.png){fig-align='center' width=960}\n:::\n:::\n\n:::\n\n## Sampling and metric densities\n\n![](images/density.png){fig-align=\"center\"}\n\n## Example 2 - `existing` {.smaller}\n\n::: {.fragment .fade-in}\nAugmenting an `existing` sample can be done using the *Adapted Hypercube Evaluation of a Legacy Sample (AHELS)* algorithm. Originally presented by [Malone, Minansy & Brungard (2019)](https://peerj.com/articles/6451/).\n:::\n\n::: {.fragment .fade-in}\n`sample_ahels()` works by:\n:::\n\n::: incremental\n-   Determining representation of `existing` sample.\n\n-   Determining number of additional samples that can / need to be added.\n\n-   Generate quantile and covariance matrix of ALS metrics.\n\n-   Identify where new samples are needed to balance quantile density and sampling density.\n\n-   Iteratively locate samples.\n:::\n\n##  {auto-animate=\"true\"}\n\nWe have our `existing` sample\n\n``` {.r code-line-numbers=\"1-2\"}\n#--- simple random sampling ---#\nexisting <- sample_srs(raster = mr, nSamp = 50, plot = TRUE)\n```\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](presentation_files/figure-revealjs/unnamed-chunk-11-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n##  {auto-animate=\"true\"}\n\nNow we can use the `sample_ahels()` algorithm with our `als` metrics.\n\n``` {.r code-line-numbers=\"5-6\"}\n#--- simple random sampling ---#\nexisting <- sample_srs(raster = mr, nSamp = 50, plot = TRUE)\n\n#--- augment sample network using sample_ahels ---#\n#--- perform ahels sampling ---#\nsample_ahels(mraster = mr,\n             existing = existing,\n             nSamp = 50)\n```\n\n##  {auto-animate=\"true\"}\n\nSpecify our `existing` sample.\n\n``` {.r code-line-numbers=\"5-7\"}\n#--- simple random sampling ---#\nexisting <- sample_srs(raster = mr, nSamp = 50, plot = TRUE)\n\n#--- augment sample network using sample_ahels ---#\n#--- perform ahels sampling ---#\nsample_ahels(mraster = mr,\n             existing = existing,\n             nSamp = 50)\n```\n\n##  {auto-animate=\"true\"}\n\nAnd specify we want 50 new sample units (`nSamp`).\n\n``` {.r code-line-numbers=\"5-8\"}\n#--- simple random sampling ---#\nexisting <- sample_srs(raster = mr, nSamp = 50, plot = TRUE)\n\n#--- augment sample network using sample_ahels ---#\n#--- perform ahels sampling ---#\nsample_ahels(mraster = mr,\n             existing = existing,\n             nSamp = 50)\n```\n\n## `sample_ahels()` result\n\nMapped result **(A)** and plotted result **(B)**.\n\nNote ratios (black/red) and additional added samples e.g *n = 2* for each stratum.\n\n![](images/e2s.png){fig-align=\"center\"}\n\n## `sample_ahels()` result\n\n`existing` only **(A)** and addition of new samples **(B)**.\n\nWe see that metric and sample density become quite even - structurally representative.\n\n![](images/hist.png){fig-align=\"center\"}\n\n## Summary {.smaller}\n\n::: {.fragment .fade-in}\n-   Structurally guided sampling methods show promise for *model-based* sampling\n:::\n\n::: {.fragment .fade-in}\n-   The `sgsR` package provides many methods to implement SGS approaches\n:::\n\n::: {.fragment .fade-in}\n-   We presented a few examples of `sgsR` functionality\n:::\n\n::: {.fragment .fade-in}\n-   If you want to know more feel free to come and talk to me, or use the link on the slide below for documentation and vignettes\n:::\n\n::: {.fragment .fade-in}\n![](images/logo.png){fig-align=\"center\" width=\"205\"}\n:::\n\n## Thank you!\n\n<center>\n\nSpecial thanks to the Canadian Wood Fibre Centre for funding this research!\n\n***My Twitter: [\\@GoodbodyT](https://twitter.com/GoodbodyT)***\n\n***IRSS Twitter: [\\@IRSS_UBC](https://twitter.com/IRSS_UBC)***\n\n</center>\n\n***Collaborators***\n\n::: columns\n::: {.column width=\"40%\"}\n-   Martin Queinnec\n-   Joanne White\n-   Andrew Hudak\n-   Ruben Valbuena\n-   Murray Woods\n-   David Auty\n:::\n\n::: {.column width=\"10%\"}\n:::\n\n::: {.column width=\"40%\"}\n-   Antoine Leboeuf\n-   Ian Sinclair\n-   Grant McCartney\n-   Jean-Francois Prieur\n-   Piotr Tompalski\n:::\n:::\n\n## Thank you!\n\n![](images/affiliations.png)\n",
    "supporting": [
      "presentation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n\r\n      // dispatch for htmlwidgets\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for reveal\r\n    if (window.Reveal) {\r\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\r\n        fireSlideChanged(event.previousSlide, event.currentSlide);\r\n      });\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}